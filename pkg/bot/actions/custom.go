package actions

import (
	"bytes"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"os"
	"path/filepath"
	"strings"
	"time"
)

// CustomActionConfig defines the structure of the JSON configuration file for custom actions
type CustomActionConfig struct {
	Name          string          `json:"name"`
	Description   string          `json:"description"`
	URL           string          `json:"url"`
	ResponseToLLM bool            `json:"response_to_llm"`
	Parameters    json.RawMessage `json:"parameters"` // JSON Schema for the payload
}

// CustomAction implements the Action interface for user-defined actions
type CustomAction struct {
	Config CustomActionConfig
	Client *http.Client
}

func (a *CustomAction) GetSchema() ActionSchema {
	return ActionSchema{
		Name:        a.Config.Name,
		Description: a.Config.Description,
		Parameters:  a.Config.Parameters,
	}
}

func (a *CustomAction) Execute(ctx ActionContext, payload json.RawMessage) error {
	// The payload is the JSON object generated by the LLM
	// We send this directly to the configured URL

	// Ensure we have a client
	client := a.Client
	if client == nil {
		client = &http.Client{Timeout: 30 * time.Second}
	}

	// Create request
	req, err := http.NewRequest("POST", a.Config.URL, bytes.NewReader(payload))
	if err != nil {
		return fmt.Errorf("failed to create request for action %s: %w", a.Config.Name, err)
	}
	req.Header.Set("Content-Type", "application/json")
	req.Header.Set("User-Agent", "WhatsABladeRunner/1.0")

	// Execute request
	resp, err := client.Do(req)
	if err != nil {
		return fmt.Errorf("failed to execute action %s: %w", a.Config.Name, err)
	}
	defer resp.Body.Close()

	// Read response
	body, err := io.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body for action %s: %w", a.Config.Name, err)
	}

	// Check status code - maybe treat non-2xx as error?
	// For now, let's just log it if it's an error, but return the body if response_to_llm is true
	if resp.StatusCode >= 400 {
		fmt.Printf("Action %s returned status %d: %s\n", a.Config.Name, resp.StatusCode, string(body))
	} else {
		fmt.Printf("Action %s executed successfully (Status %d)\n", a.Config.Name, resp.StatusCode)
	}

	// If configured to return response to LLM
	if a.Config.ResponseToLLM && ctx.ToolOutputs != nil {
		output := fmt.Sprintf("Action '%s' response (Status %d):\n%s", a.Config.Name, resp.StatusCode, string(body))
		*ctx.ToolOutputs = append(*ctx.ToolOutputs, output)
	}

	return nil
}

// LoadCustomActions scans the given directory for .json files and registers them
func LoadCustomActions(dir string, registry *Registry) error {
	// Check if directory exists
	if _, err := os.Stat(dir); os.IsNotExist(err) {
		// optional directory, just return
		return nil
	}

	entries, err := os.ReadDir(dir)
	if err != nil {
		return fmt.Errorf("failed to read custom actions directory: %w", err)
	}

	for _, entry := range entries {
		if entry.IsDir() || !strings.HasSuffix(entry.Name(), ".json") {
			continue
		}

		path := filepath.Join(dir, entry.Name())
		content, err := os.ReadFile(path)
		if err != nil {
			fmt.Printf("Warning: failed to read custom action file %s: %v\n", entry.Name(), err)
			continue
		}

		var config CustomActionConfig
		if err := json.Unmarshal(content, &config); err != nil {
			fmt.Printf("Warning: failed to parse custom action file %s: %v\n", entry.Name(), err)
			continue
		}

		// Validation
		if config.Name == "" || config.URL == "" {
			fmt.Printf("Warning: custom action %s missing name or url\n", entry.Name())
			continue
		}

		// Use default empty object for parameters if missing, to avoid nil pointer or invalid schema issues
		if config.Parameters == nil {
			config.Parameters = json.RawMessage(`{}`)
		}

		action := &CustomAction{
			Config: config,
			Client: &http.Client{Timeout: 30 * time.Second},
		}

		registry.Register(action)
		fmt.Printf("Registered custom action: %s\n", config.Name)
	}

	return nil
}
